# Hash Table 
해시 테이블 = 버켓배열 + 해시함수
항목들의 키를 주소로 매핑 1차원 배열에 사전 항목들을 저장
# 성능
탐색, 삽입, 삭제 : O(n)-최악, O(1)-기대시간.

# 설계

## 해시테이블 = 해시함수 + 버켓배열

- **해시함수** = 해시 코드맵 + 압축맵

## 해시 테이블의 구성

해시 테이블 = 해시함수(해시 코드맵 + 압축맵) + 버켓 배열

---

## 압축맵

문제에서 요구된 조건은 **버켓 배열의 크기를 31개**로 세팅하는 것입니다. 여기서 왜 31로 설정했는지에 대한 이유는 다음과 같습니다:

### 이유

1. **해시 충돌 최소화**: 서로 다른 key들이 해시 함수에 의해 동일한 인덱스로 매핑될 수 있습니다. 해시 테이블의 크기를 짝수나 제곱수로 설정하면 충돌 가능성이 커질 수 있습니다.
2. **모듈러 연산 효과**: 소수로 설정했을 경우, 해시 값이 더 고르게 분포되는 경향이 있습니다.
3. **해시 함수의 성능 최적화**: 소수로 설정하면 해시 함수의 분포 성능이 최적화됩니다.
4. **사이클 회피**: 특정 패턴의 키들이 일정 간격으로 해시 테이블에서 충돌하는 사이클이 발생할 수 있습니다. 소수 크기를 사용하면 이러한 사이클을 최소화할 수 있습니다.

결론: **31**은 소수이기 때문에 선택되었습니다.

---

## 해시 코드맵

### 고려사항

1. **충돌 방지**: 최대한 해시 충돌을 방지할 수 있는 방법을 고려해야 합니다.
   - **대안**: 해시 코드맵 방식 중 **다항누적 방식 (Polynomial Accumulation)** 을 적용하기로 결정했습니다.
   - **이유**: 다항누적 방식이 문자열에 적합하다고 알려져 있습니다. 학교 알고리즘 교안의 "해시테이블" 강의 자료를 참고했습니다.

### 방법

1. **비트 분할**: 키의 비트들을 고정길이(예: 8, 16, 32 bits)로 분할합니다.
   - 예: `a(0), a(1), a(2), ......, a(n-1)`
2. **다항식 계산**: 고정값 `z`를 사용하여 각 요소의 위치에 따른 계산을 부과한 다항식 `p(z)`를 계산합니다.
   - `p(z) = a0 + a1*z + a2*z^2 + a3*z^3 + ..... + a(n-1)*z^(n-1)`
   - 여기서 **오버플로우**가 발생할 수 있는데, 이 부분을 적절히 처리해야 합니다. 교안에서는 오버플로우를 무시하라고 했지만, 실제 코딩 시에는 처리 방법을 고려해야 합니다.

### 기대 성능

- 고정값 `z=33`을 선택할 경우, 50

